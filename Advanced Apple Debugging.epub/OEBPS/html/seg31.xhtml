<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" type="text/css" href="dbg.css"/>
  <title>Chapter 21: Script Bridging with SBValue &amp; Memory</title>
</head>
<body class="segment-chapter">

<!-- metadata: nil  -->


<h1 class="segment-chapter">Chapter 21: Script Bridging with SBValue &amp; Memory</h1>

<p>So far, when evaluating JIT code (i.e. Objective-C, Swift, C, etc. code that‚Äôs executed through your Python script), you‚Äôve used a small set of APIs to evaluate the code.
</p>
<p>For example, you‚Äôve used <code>SBDebugger</code> and <code>SBCommandReturnObject</code>‚Äôs <code><em>HandleCommand</em></code> method to evaluate code. <code>SBDebugger</code>‚Äôs <code>HandleCommand</code> goes straight to <code>stderr</code>, while you have a little more control over where the <code>SBCommandReturnObject</code> result ends up. Once evaluated, you had to manually parse the return output for anything of interest. This manual searching of the output from the JIT code is a bit unsightly. Nobody likes stringly typed things!
</p>
<p>So, it‚Äôs time to talk about a new class in the lldb Python module, <code><em>SBValue</em></code>, and how it can simplify the parsing of JIT code output.
</p>
<p>Open up the Xcode project named <em>Allocator</em> in the <em>starter</em> folder for this chapter. This is a simple application which dynamically generates classes based upon input from a text field.
</p><div class="image-55"><img src="graphics/img119.png"  alt="" title="" /></div>
<p>This is accomplished by taking the string from the text field and using it as an input to the <code>NSClassFromString</code> function. If a valid class is returned, it‚Äôs initialized using the plain old <code>init</code> method. Otherwise, an error is spat out.
</p>
<p>Build and run the application on any iOS 11 Simulator. You‚Äôll make zero modifications to this project, yet you‚Äôll explore objects‚Äô layouts in memory through <code>SBValue</code>, as well as manually with pointers through LLDB.
</p>
<h2 class="segment-chapter">A detour down memory layout lane</h2>

<p>To truly appreciate the power of the <code>SBValue</code> class, you‚Äôre going to explore the memory layout of three unique objects within the Allocator application. You‚Äôll start with an Objective-C class, then explore a Swift class with no superclass, then finally explore a Swift class that inherits from <code>NSObject</code>.
</p>
<p>All three of these classes have three properties with the following order:
</p>
<ul>
<li>
<p>A <code>UIColor</code> called <code><em>eyeColor</em></code>.
</p></li>

<li>
<p>A language specific string (<code>String</code>/<code>NSString</code>) called <code><em>firstName</em></code>.
</p></li>

<li>
<p>A language specific string (<code>String</code>/<code>NSString</code>) called <code><em>lastName</em></code>.
</p></li>
</ul>

<p>Each instance of these classes is initialized with the same values. They are:
</p>
<ul>
<li>
<p><code>eyeColor</code> will be <code>UIColor.brown</code> or <code>[UIColor brownColor]</code> depending on language.
</p></li>

<li>
<p><code>firstName</code> will be <code>&quot;Derek&quot;</code> or <code>@&quot;Derek&quot;</code> depending on language.
</p></li>

<li>
<p><code>lastName</code> will be <code>&quot;Selander&quot;</code> or <code>@&quot;Selander&quot;</code> depending on language.
</p></li>
</ul>

<h3 class="segment-chapter">Objective-C memory layout</h3>

<p>You‚Äôll explore the Objective-C class first, as it‚Äôs the foundation for how these objects are laid out in memory. Jump over to the <em>DSObjectiveCObject.h</em> and take a look at it. Here it is for your reference:
</p><pre class="code-block"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DSObjectiveCObject</span> : <span class="hljs-title">NSObject</span></span>

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIColor</span> *eyeColor;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *firstName;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *lastName;

<span class="hljs-keyword">@end</span></pre>
<p>As mentioned earlier, there are three properties: <code>eyeColor</code>, <code>firstName</code>, and <code>lastName</code> in that order.
</p>
<p>Jump over to the implementation file <em>DSObjectiveCObject.m</em> and give it a gander to understand what‚Äôs happening when this Objective-C object is initialized:
</p><pre class="code-block"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DSObjectiveCObject</span></span>

- (<span class="hljs-keyword">instancetype</span>)init
{
  <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) {
    <span class="hljs-keyword">self</span>.eyeColor = [<span class="hljs-built_in">UIColor</span> brownColor];
    <span class="hljs-keyword">self</span>.firstName = <span class="hljs-string">@"Derek"</span>;
    <span class="hljs-keyword">self</span>.lastName = <span class="hljs-string">@"Selander"</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
<span class="hljs-keyword">@end</span></pre>
<p>Nothing too crazy. The properties will be initialized to the values just described above.
</p>
<p>When this is compiled, this Objective-C class will actually look like a C struct. The compiler will create a struct similar to the following pseudocode:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> DSObjectiveCObject {
  Class isa;
  <span class="hljs-built_in">UIColor</span> *eyeColor;
  <span class="hljs-built_in">NSString</span> *firstName
  <span class="hljs-built_in">NSString</span> *lastName
}</pre>
<p>Take note of the <code>Class isa</code> variable as the first parameter. This is the magic behind an Objective-C class being considered an Objective-C class. This <code>isa</code> value is always the first value in an object instance‚Äôs memory layout, and is a pointer to the class the object is an instance of. After that, the properties are added to this struct in the order they were written in your source code.
</p>
<p>Let‚Äôs see this in action through LLDB. Perform the following steps:
</p>
<ol>
<li>
<p>Make sure the <em>DSObjectiveCObject</em> is selected in the <code>UIPickerView</code>.
</p></li>

<li>
<p>Tap on the <em>Allocate Class</em> button.
</p></li>

<li>
<p>Once the reference address is spat out in the console, copy that address to your clipboard.
</p></li>

<li>
<p>Pause execution and bring up the LLDB console window.
</p></li>
</ol>
<div class="image-90"><img src="graphics/img120.png"  alt="" title="" /></div>
<p>An instance of the <code>DSObjectiveCObject</code> has been created. You‚Äôll now use LLDB to spelunk into offsets of this object‚Äôs contents.
</p>
<p>Copy the memory address from the console output and make sure <code>po</code>‚Äôing it will give you a valid reference (e.g. you‚Äôre not stopped on a Swift stack frame when printing out this address).
</p>
<p>For my case, I got the pointer <code>0x600000031f80</code>. As always, yours will be different. Print out the address through LLDB:
</p><pre class="code-block">(lldb) po 0x600000031f80</pre>
<p>You should get this expected line of output:
</p><pre class="code-block">&lt;DSObjectiveCObject: 0x600000031f80&gt;</pre>
<p>Since this can be treated as a C struct, you‚Äôll start spelunking into offsets of this pointer‚Äôs contents.
</p>
<p>In the LLDB console, type the following (replacing the pointer with yours):
</p><pre class="code-block">(lldb) po *(id *)(0x600000031f80)</pre>
<p>This casts the pointer to a pointer to an <code>id</code> and then dereferences it. This will access the object‚Äôs <code><em>isa</em></code> pointer.
</p>
<p>You should see this output:
</p><pre class="code-block">DSObjectiveCObject</pre>
<p>That‚Äôs the class object‚Äôs description, as expected.
</p>
<p>Let‚Äôs look at another way of viewing this memory. Use the <code><em>x</em></code> command (aka <code>examine</code>, a port from GDBs popularity with this command) to jump to the starting pointer, then <code>po</code> it. Enter the following:
</p><pre class="code-block">(lldb) x/gx 0x600000031f80</pre>
<p>This command says the following:
</p>
<ul>
<li>
<p>Examine the memory (<code>x</code>)
</p></li>

<li>
<p>Print out the size of a <em>giant</em> word, (64 bits, or 8 bytes) (<code>g</code>)
</p></li>

<li>
<p>Finally, format it in hexadecimal (<code>x</code>).
</p></li>
</ul>

<p>If, hypothetically, you only wanted to view the first byte at this location in binary instead, you could type <code>x/bt 0x600000031f80</code> instead. This would be interpreted as examine (<code>x</code>), a byte (<code>b</code>) in binary (<code>t</code>). The <code>examine</code> command is definitely one of those nice commands to keep in your toolkit when exploring memory.
</p>
<p>You‚Äôll see the following output (or at least, similar output, as the values will be different for you):
</p><pre class="code-block">0x600000031f80: 0x0000000108b06568</pre>
<p>This gives you output that tells you the value at memory address <code>0x600000031f80</code> contains <code>0x0000000108b06568</code>. Well, it does for me!
</p>
<p>Jumping back to the task at hand, take the address printed out by the <code>x/gx</code> command and print out this new address using <code>po</code>.
</p><pre class="code-block">(lldb) po 0x0000000108b06568</pre>
<p>Once again, this will print out the <code>isa</code> class, which is the <code>DSObjectiveCObject</code> class. This is an alternative way to print out the <code>isa</code> instance, which might give more insight into what‚Äôs happening. However, that took two LLDB commands instead of one, so you‚Äôll stick to dereferencing the pointer and not use the <code>x/gx</code> command.
</p>
<p>Let‚Äôs jump a little further into the <code>eyeColor</code> property. In the LLDB console:
</p><pre class="code-block">(lldb) po *(id *)(0x600000031f80 + 0x8)</pre>
<p>This says ‚Äústart at <code>0x600000031f80</code> (or equivalent), go up 8 bytes and get the contents pointed at by this pointer.‚Äù You‚Äôll get the following output:
</p><pre class="code-block">UIExtendedSRGBColorSpace 0.6 0.4 0.2 1</pre>
<p>How did I get to the number 8? Try this out in LLDB:
</p><pre class="code-block">(lldb) po sizeof(Class)</pre>
<p>The <code>isa</code> variable is of type <code>Class</code>. So by knowing how big a <code>Class</code> is, you know how much space that takes up in the struct, and therefore you know the offset of <code>eyeColor</code>.
</p>
<div class="note">
<p><em>Note</em>: When working with 64-bit architectures (x64 or ARM64), all pointers will be 8 bytes. In addition, the <code>Class</code> class itself is 8 bytes. This means in 64-bit architecture, all you need to do to move between different types is jump by 8 bytes!
</p>
<p>There are types which are different sizes in bytes, such as <code>int</code>, <code>short</code>, <code>bool</code> and others, and the compiler may pad that memory to fit into a predefined size 8 byte size on 64-bit architectures. However, there‚Äôs no need to worry about that for now, since this <code>DSObjectiveCObject</code> class only contains pointers to <code>NSObject</code> subclasses, along with the <code>Class</code> object held in the <code>isa</code> variable.
</p></div>

<p>Keep on going. Increment the offset by another 8 bytes in LLDB:
</p><pre class="code-block">(lldb) po *(id *)(0x600000031f80 + 0x10)</pre>
<p>You‚Äôre adding another 8 to get 0x10 in hexadecimal (or 16 in decimal). You‚Äôll get <code>@&quot;Derek&quot;</code>, which is the contents of the <code>firstName</code> property. Increment by yet another 8 bytes to get the <code>lastName</code> property:
</p><pre class="code-block">(lldb) po *(id *)(0x600000031f80 + 0x18)</pre>
<p>You‚Äôll get <code>@&quot;Selander&quot;</code>. Cool, right?
</p>
<p>Let‚Äôs visually revisit what you just did to hammer this home:
</p><div class="image-90"><img src="graphics/img121.png"  alt="" title="" /></div>
<p>You started at a base address that pointed to the instance of <code>DSObjectiveCObject</code>. For this particular example, this starting address is at <code>0x600000031f80</code>. You started by dereferencing this pointer, which gave you the <code>isa</code> variable, then you jumped by offsets of 8 bytes to the next Objective-C property, dereferenced the pointer at that offset, cast it to type <code>id</code> and spat it out to the console.
</p>
<p>Spelunking memory is a fun and instructional way to see what‚Äôs happening behind the scenes. This lets you appreciate the <code>SBValue</code> class even more. But you‚Äôre not at the point of talking about the <code>SBValue</code> class, as you still have two more classes to explore. The first is a Swift class with no superclass, and the second is a Swift class which inherits from <code>NSObject</code>. You‚Äôll explore the non superclass Swift object first.
</p>
<h3 class="segment-chapter">Swift memory layout with no superclass</h3>

<div class="note">
<p><em>Note</em>: It‚Äôs worth mentioning right up front: the Swift ABI is still fluctuating. This means the information below could change before the Swift ABI completes. The day a new version of Xcode breaks the information in the following section, feel free to complain in ALL CAPS in the forums!
</p></div>

<p>Time to explore a Swift class with no superclass! In the Allocator project, jump to <em>ASwiftClass.swift</em> and take a look at what‚Äôs there.
</p><pre class="code-block"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ASwiftClass</span> </span>{
  <span class="hljs-keyword">let</span> eyeColor = <span class="hljs-type">UIColor</span>.brown
  <span class="hljs-keyword">let</span> firstName = <span class="hljs-string">"Derek"</span>
  <span class="hljs-keyword">let</span> lastName = <span class="hljs-string">"Selander"</span>
  
  <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>() { }
}</pre>
<p>Here, you have the Swift equivalent for <code>DSObjectiveCObject</code> with the obvious ‚ÄúSwifty‚Äù changes.
</p>
<p>Again, you can imagine this Swift class as a C struct with some interesting differences from its Objective-C counterpart. Check out the following pseudocode:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> ASwiftClass {
  Class isa;
  uint64_t refCounts;

  <span class="hljs-built_in">UIColor</span> *eyeColor;

  <span class="hljs-keyword">struct</span> _StringCore {
    uintptr_t _baseAddress;
    uintptr_t _countAndFlags;
    uintptr_t _owner;
  } firstName;

  <span class="hljs-keyword">struct</span> _StringCore {
    uintptr_t _baseAddress;
    uintptr_t _countAndFlags;
    uintptr_t _owner;
  } firstName;
}</pre>
<p>Pretty interesting right? You still have that <code>isa</code> variable as the first parameter.
</p>
<p>After the <code>isa</code> variable, there‚Äôs 8 bytes reserved for a <code>refCounts</code> variable. This differs to your typical Objective-C object which doesn‚Äôt contain this reference counter at this offset. Note the <code>uint64_t</code> type, which indicates that 8 bytes are reserved ‚Äî even in a 32 bit platform. This differs from the <code>uintptr_t</code>, which will be 32 bit or 64 bit depending on the hardware.
</p>
<p>Next, you have the normal <code>UIColor</code>, but that‚Äôs where this <code>ASwiftClass</code> struct goes completely off the rails.
</p>
<p>A Swift <code>String</code> is a very interesting ‚Äúobject‚Äù. In fact, a Swift <code>String</code> is a struct within the <code>ASwiftClass</code> struct.There‚Äôs three parameters for every Swift <code>String</code> when you‚Äôre jumping around in memory:
</p>
<ul>
<li>
<p>There is the actual pointer to the string‚Äôs character data.
</p></li>

<li>
<p>Following that are the length and flags mixed into one parameter; it could be Unichar, ASCII, or some other crazy thing I don‚Äôt know how to interpret.
</p></li>

<li>
<p>Finally, you have a reference to any of its owners.
</p></li>
</ul>

<p>Since you are declaring these strings at compile time (with those <code>let</code> declarations), there‚Äôs no need for owners since the compiler will only need to reference offsets to the actual location of the strings, as they‚Äôre immutable.
</p>
<p>This Swift <code>String</code> struct actually makes the assembly calling convention rather interesting. If you pass a <code>String</code> to a function, it will actually pass in three parameters (and use three registers) instead of a pointer to a struct containing the three parameters (in one register). Don‚Äôt believe me? Check it out yourself when you‚Äôre done with this chapter!
</p>
<p>Back to LLDB and jumping through an object.
</p>
<p>Clear the LLDB screen with a <em>‚åò + K</em>, then resume the application through LLDB or the Xcode GUI.
</p>
<p>You‚Äôre going to do the exact same thing with the <code>ASwiftClass</code> that you did with <code>DSObjectiveCObject</code>. Use the developer/designer ‚Äúapproved‚Äù <code>UIPickerView</code> and select <em>Allocator.SwiftClass</em>. Remember, to correctly reference a Swift class (i.e. in <code>NSClassFromString</code> and friends), you need the module name prepended to the classname with a period separating the two.
</p>
<p>Tap the <em>Allocate Class</em> button and copy the memory address spat out to the console.
</p><div class="image-60"><img src="graphics/img122.png"  alt="" title="" /></div>
<p>You‚Äôll get something similar to the following:
</p><pre class="code-block">&lt;Allocator.ASwiftClass: 0x61800009d830&gt;</pre>
<p>Usually, Swift hides the pointer in the <code>description</code> and <code>debugDescription</code> methods, but there‚Äôs something sneaky compiled into this project that you‚Äôll come across in a second.
</p>
<p>For now, grab that memory address and stick it in the clipboard.
</p>
<p>First use LLDB to ensure it‚Äôs valid, by <code>po</code>-ing it:
</p><pre class="code-block">(lldb) po 0x61800009d830</pre>
<p>If you get something different than the following, you should be more than somewhat surprised:
</p><pre class="code-block">&lt;Allocator.ASwiftClass: 0x61800009d830&gt;</pre>
<p>Even though this is a pure Swift object, you were able to get the dynamic description in the Objective-C context. That means you can climb the class hierarchy to see the parent class!
</p><pre class="code-block">(lldb) po [0x61800009d830 superclass]</pre>
<p>You‚Äôll get an interesting class with the name of:
</p><pre class="code-block">SwiftObject</pre>
<p>You‚Äôll explore this class more in a second. For now, start jumping around in memory. Dereference the pointer‚Äôs address and prove to yourself that the first parameter is that <code>isa</code> <code>Class</code> variable:
</p><pre class="code-block">(lldb) po *(id *)0x61800009d830</pre>
<p>You‚Äôll get <code>Allocator.ASwiftClass</code>. Now check out that reference counter variable:
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x8)</pre>
<p>You‚Äôll get something similar to the following:
</p><pre class="code-block">0x0000000000000002</pre>
<p>It‚Äôs clear that the address here is not a Objective-C address, since <code>*(id *)0x0000000200000004</code> would point to a class if it were a valid instance/class. Instead, this is the reference counter unique to Swift classes. Let‚Äôs see how this thing works.
</p>
<p>Use LLDB to manually retain this class:
</p><pre class="code-block">(lldb) po [0x61800009d830 retain]</pre>
<p>Press the up arrow twice to retrieve the previous command and execute it again:
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x8)</pre>
<p>You‚Äôll now get a slightly different number:
</p><pre class="code-block">0x0000000200000002</pre>
<p>Notice the middle hex value jumped up by 2. Shooting from the hip, this giant word should actually be viewed as 2 separate integer (32-bit) fields instead of one 64-bit field. See if <code>release</code>‚Äôing this reference brings the count back down:
</p><pre class="code-block">(lldb) po [0x61800009d830 release]</pre>
<p>Yep, up arrow twice again, then Enter.
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x8)</pre>
<p>You‚Äôll get your happy, original value:
</p><pre class="code-block">0x0000000000000002</pre>
<p>Now that you‚Äôve got past the <code>isa</code> and the <code>refCounts</code> it‚Äôs time to turn your attention to those lovely properties in the <code>ASwiftClass</code> instance.
</p>
<p>Clear the screen to start fresh, then increment your offset amount in LLDB.
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x10)</pre>
<p>You‚Äôll get the internal representation of <code>UIColor</code>‚Äôs brown:
</p><pre class="code-block"><span class="hljs-type">UIExtendedSRGBColorSpace</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.4</span> <span class="hljs-number">0.2</span> <span class="hljs-number">1</span></pre>
<p>Jump another 8 bytes and start exploring the firstName String structure.
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x18)
0x0000000101f850d0</pre>
<p>As you saw in that pseudocode struct, this is the actual base address for the start of the Swift string. Internally this base address can be viewed as a C <code>char*</code> or a C <code>unichar*</code> (useful for all those üí© emojis). So all you need to do is cast it to the correct type. Since the Swift String <code>&quot;Derek&quot;</code> definitely falls in the ASCII realm, cast this address to a <code>char*</code> instead of type <code>id</code>:
</p><pre class="code-block">(lldb) po *(char* *)(0x61800009d830 + 0x18)
&quot;Derek&quot;</pre>
<p>Now take a look at the <code><em>_countAndFlags</em></code> offset. Bump your offset to <code>0x20</code> and revert back to using a casting type of <em>id</em> and keep on exploring. <code>id</code> is a good default, because it resolves to an Objective-C object if it can, and to a hex address if it can‚Äôt.
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x20)</pre>
<p>You‚Äôll get the following:
</p><pre class="code-block">0x0000000000000005</pre>
<p>Again, this represents the flags and length. Since &quot;Derek&quot; is of length 5, you get 5 in the least significant location of the hex value. The remaining zeroes indicate there are no flags being applied (i.e. as the format for <code>unichar</code> instead of <code>char</code>).
</p>
<p>Finally, up your offset amount and go after the <code><em>_owner</em></code> part of the Swift String:
</p><pre class="code-block">(lldb) po *(id *)(0x61800009d830 + 0x28)</pre>
<p>This will dump out <code>nil</code> since that‚Äôs the Objective-C equivalent of <code>0x0000000000000000</code>. As mentioned earlier, there‚Äôs no need for an ‚Äúowner‚Äù since this string is created at compile time.
</p>
<p>No need to go after the <code><em>lastName</em></code> property. You‚Äôve got the idea of how this works.
</p>
<h3 class="segment-chapter">The SwiftObject class: a detour in the detour</h3>

<p>But wait, you‚Äôve totally overlooked the <em>SwiftObject</em> class, which was the superclass of <code>ASwiftClass</code>! Let‚Äôs use <em>image lookup</em> to dump methods implemented by this class.
</p>
<p>In LLDB, type the following:
</p><pre class="code-block">(lldb) image lookup -rn SwiftObject</pre><div class="image-80"><img src="graphics/img123.png"  alt="" title="" /></div>
<p>I don‚Äôt know about you, but I am tired of looking at that ugly formatting output. It‚Äôs too hard to read it correctly. If you‚Äôve made this far in this book, you know you have the freedom to change anything necessary to make your life easier.
</p>
<p>Use the lldb Python API to make a <i>much</i> prettier query:
</p><pre class="code-block">(lldb) script srch = lldb.target.FindGlobalFunctions(&apos;SwiftObject&apos;, 0, lldb.eMatchTypeRegex)</pre>
<p>You‚Äôre declaring a search query which is of type <code><em>SBSymbolContextList</em></code> and assigned it to <code><em>srch</em></code>. This is somewhat like a Python <code>list</code> of <code><em>SBSymbolContext</em></code>‚Äôs.
</p>
<p>I‚Äôll leave it to you to grab the documentation of <code><em>FindGlobalFunctions</em></code>  by <code><em>gdocumentation</em></code>‚Äôing <code><em>SBTarget</em></code>.
</p>
<p>Now type this into LLDB:
</p><pre class="code-block">(lldb) script print &quot;\n&quot;.join(map(lambda a: str(a.symbol.name), srch))</pre>
<p>This applies a lambda to grab the function names and join each object in this <code>list</code> by a newline.
</p><div class="image-80"><img src="graphics/img124.png"  alt="" title="" /></div>
<p>Much better. Maybe that would be a good script to write in an upcoming chapter.
</p>
<p>OK, back to the goal at hand. You‚Äôre exploring the methods implemented by this Objective-C-ish <code>SwiftObject</code> class. Since it‚Äôs using Objective-C code, it‚Äôs fair game for method swizzling. Take note of the <code><em>description</em></code> and <code><em>debugDescription</em></code> methods implemented by this <code>SwiftObject</code>.
</p>
<p>The Allocator project is actually swizzling <em>debugDescription</em> on the <code>SwiftObject</code> to alter the output and show the pointer for the <code>SwiftObject</code> subclass. This logic is found in <em>NSObject+DS</em><em>_</em><em>SwiftObject.m</em>. The Swift language and the Swift LLDB context go out of their way to hide this pointer, which can be quite annoying.
</p>
<p>The dumped output means any Swift class is still open for swizzling and Objective-C funtime er... runtime amusement, whether it inherits from <code>NSObject</code>, or from no superclass at all. It‚Äôs good to keep this in mind for security reasons within your application.
</p>
<h3 class="segment-chapter">Swift memory layout with NSObject superclass</h3>

<p>Final one. You know the drill, so we‚Äôll speed this one up a bit and skip the actual debugging session.
</p>
<p>Check out the sourcecode for <em>ASwiftNSObjectClass.swift</em>:
</p><pre class="code-block"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ASwiftNSObjectClass</span>: <span class="hljs-title">NSObject</span> </span>{
  <span class="hljs-keyword">let</span> eyeColor = <span class="hljs-type">UIColor</span>.brown
  <span class="hljs-keyword">let</span> firstName = <span class="hljs-string">"Derek"</span>
  <span class="hljs-keyword">let</span> lastName = <span class="hljs-string">"Selander"</span>
  
  <span class="hljs-keyword">required</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() { }
}</pre>
<p>It‚Äôs the same thing as the <code>ASwiftClass</code>, except it inherits from <code>NSObject</code> instead of from nothing.
</p>
<p>So is there any difference in the generated C struct pseudocode?
</p><pre class="code-block"><span class="hljs-keyword">struct</span> ASwiftNSObjectClass {
  Class isa;
  uintptr_t referenceCounts;

  <span class="hljs-built_in">UIColor</span> *eyeColor;

  <span class="hljs-keyword">struct</span> _StringCore {
    uintptr_t _baseAddress;
    uintptr_t _countAndFlags;
    uintptr_t _owner;
  } firstName;

  <span class="hljs-keyword">struct</span> _StringCore {
    uintptr_t _baseAddress;
    uintptr_t _countAndFlags;
    uintptr_t _owner;
  } firstName;
}</pre>
<p>Nope! There‚Äôs no struct pseudocode difference when compared to the <code>ASwiftClass</code>. The main difference is it‚Äôs a lot easier to introspect this class since <code>NSObject</code> implements far more methods than the <code>SwiftObject</code> class.
</p>
<p>Let‚Äôs skip the debugging session and just talk about what will happen when you try <em>retain</em>‚Äôing an instance of this class: the <em>refCounts</em> variable will <i>not</i> be modified. This makes sense because Objective-C has its own implementation of <code>retain</code>/<code>release</code> that‚Äôs different from the Swift implementation.
</p>
<p>You can finally look at the <code><em>SBValue</em></code> class I‚Äôve been itching to describe to you!
</p>
<h2 class="segment-chapter">SBValue</h2>

<p>Yay! Time to talk about this awesome class.
</p>
<p><code><em>SBValue</em></code> is responsible for interpreting the parsed expressions from your JIT code. Think of <code>SBValue</code> as a representation that lets you explore the members within your object, just as you did above, but without all that ugly dereferencing. Within the <code>SBValue</code> instance, you can easily access all members of your struct... er, I mean, your Objective-C or Swift classes.
</p>
<p>Within the <code>SBTarget</code> and <code>SBFrame</code> class, there‚Äôs a method named <code><em>EvaluateExpression</em></code>, which will take your expression as a Python <code>str</code> and return an <code>SBValue</code> instance. In addition, there‚Äôs an optional second parameter that lets you specify how you want your code to be parsed. You‚Äôll start without the optional second parameter, and explore it later.
</p>
<p>Jump back into the LLDB console and make sure the Allocator project is still running. Make sure the LLDB console is up (i.e. the program is paused), clear the console and type the following:
</p><pre class="code-block">(lldb) po [DSObjectiveCObject new]</pre>
<p>You‚Äôll get something similar to the following:
</p><pre class="code-block">&lt;DSObjectiveCObject: 0x61800002eec0&gt;</pre>
<p>This ensures you can create a valid instance of a <code>DSObjectiveCObject</code>.
</p>
<p>This code works, so you can apply it to the <code>EvaluateExpression</code> method of either the global <code>SBTarget</code> or <code>SBFrame</code> instance:
</p><pre class="code-block">(lldb) script lldb.frame.EvaluateExpression(&apos;[DSObjectiveCObject new]&apos;)</pre>
<p>You‚Äôll get the usual cryptic output with the class but no context to describe what this does:
</p><pre class="code-block">&lt;lldb.SBValue; proxy of &lt;Swig Object of type &apos;lldb::SBValue *&apos; at 0x10ac78b10&gt; &gt;</pre>
<p>You‚Äôve got to use <code>print</code> to get context for these classes:
</p><pre class="code-block">(lldb) script print lldb.target.EvaluateExpression(&apos;[DSObjectiveCObject new]&apos;)</pre>
<p>You‚Äôll get your happy <code>debugDescription</code> you‚Äôve become accustomed to.
</p><pre class="code-block">(DSObjectiveCObject *) $2 = 0x0000618000034280</pre>
<div class="note">
<p><em>Note</em>: If you mistype something, you‚Äôll still get an instance of <code>SBValue</code>, so make sure it‚Äôs printed out the item you expect it should. For example, if you mistyped the JIT code, you might get something like <code>** = &lt;could not resolve type&gt;**</code> from the <code>SBValue</code>.
</p></div>

<div class="note">
<p>You can verify the <code>SBValue</code> succeeded by checking the <code><em>SBError</em></code> instance within your <code>SBValue</code>. If your <code>SBvalue</code> was named <code>sbval</code>, you could do <code>sbval.GetError().Success()</code>, or more simply <code>sbval.error.success</code>. <code>print</code> as a quick way to see if it worked or not.
</p></div>

<p>Modify this command so you‚Äôre assigning it to the variable <code><em>a</em></code> inside the Python context:
</p><pre class="code-block">(lldb) script a = lldb.target.EvaluateExpression(&apos;[DSObjectiveCObject new]&apos;)</pre>
<p>Now apply the Python <code>print</code> function to the <code>a</code> variable:
</p><pre class="code-block">(lldb) script print a</pre>
<p>Again, you‚Äôll get something similar to the following:
</p><pre class="code-block">(DSObjectiveCObject *) $0 = 0x0000608000033260</pre>
<p>Great! You have an <code>SBValue</code> instance stored at <code>a</code> and are already knowledgeable about the memory layout of the <code>DSObjectiveCObject</code>. You know <code>a</code> is holding an <code>SBValue</code> that is a pointer to the <code>DSObjectiveCObject</code> class.
</p>
<p>You can grab the <code>description</code> of the <code>DSObjectiveCObject</code> class by using the <code>GetDescription()</code>, or more simply <code>description</code> property of <code>SBValue</code>.
</p>
<p>Type the following:
</p><pre class="code-block">(lldb) script print a.description</pre>
<p>You‚Äôll see something similar to the following:
</p><pre class="code-block">&lt;DSObjectiveCObject: 0x608000033260&gt;</pre>
<p>You can also get the <code>value</code> property, which returns a Python <code>String</code> containing the address of this instance:
</p><pre class="code-block">(lldb) script print a.value</pre>
<p>Just the value this time:
</p><pre class="code-block">0x0000608000033260</pre>
<p>Copy the output of <code>a.value</code> and ensure <code>po</code>‚Äôing this pointer gives you the original, correct reference:
</p><pre class="code-block">(lldb) po 0x0000608000033260</pre>
<p>Yup:
</p><pre class="code-block">&lt;DSObjectiveCObject: 0x608000033260&gt;</pre>
<p>If you want the address expressed in a Python number instead of a Python <code>str</code>, you can use the <code>signed</code> or <code>unsigned</code> property:
</p><pre class="code-block">(lldb) script print a.signed</pre>
<p>Like this:
</p><pre class="code-block">106102872289888</pre>
<p>Formatting the number to hexadecimal will produce the pointer to this instance of <code>DSObjectiveCObject</code>:
</p><pre class="code-block">(lldb) p/x 106102872289888</pre>
<p>And you‚Äôre back to where you were before:
</p><pre class="code-block">(long) $3 = 0x0000608000033260</pre>
<h3 class="segment-chapter">Exploring properties through SBValue offsets</h3>

<p>What about those properties stuffed inside that <code>DSObjectiveCObject</code> instance? Let‚Äôs explore those!
</p>
<p>Use the <code><em>GetNumChildren</em></code> method available to <code>SBValue</code> to get its child count:
</p><pre class="code-block">(lldb) script print a.GetNumChildren()
4</pre>
<p>You can think children as just an array. There‚Äôs a special API to traverse the children in a class called <em>GetChildAtIndex</em>, so you can explore children 0-3 in LLDB.
</p>
<p>Child 0:
</p><pre class="code-block">(lldb) script print a.GetChildAtIndex(0)
(NSObject) NSObject = {
  isa = DSObjectiveCObject
}</pre>
<p>Child 1:
</p><pre class="code-block">(lldb) script print a.GetChildAtIndex(1)
(UICachedDeviceRGBColor *) _eyeColor = 0x0000608000070e00</pre>
<p>Child 2:
</p><pre class="code-block">(lldb) script print a.GetChildAtIndex(2)
(__NSCFConstantString *) _firstName = 0x000000010db83368 @&quot;Derek&quot;</pre>
<p>Child 3:
</p><pre class="code-block">(lldb) script print a.GetChildAtIndex(3)
(__NSCFConstantString *) _lastName = 0x000000010db83388 @&quot;Selander&quot;</pre>
<p>Each of these will return an <code>SBValue</code> in itself, so you can explore that object even further if you desired. Take the <code>firstName</code> property into account. Type the following to just get the description:
</p><pre class="code-block">(lldb) script print a.GetChildAtIndex(2).description
Derek</pre>
<p>It‚Äôs important to remember the Python variable <code>a</code> is a pointer to an object. Type the following:
</p><pre class="code-block">(lldb) script a.size
8</pre>
<p>This will print out a value saying <code>a</code> is 8 bytes long. But you want to get to the actual content! Fortunately, the <code>SBValue</code> has a <em>deref</em> property that returns another <code>SBValue</code>. Explore the output with the <code>size</code> property:
</p><pre class="code-block">(lldb) script a.deref.size</pre>
<p>This returns the value <em>32</em> since it makes up the <code>isa</code>, <code>eyeColor</code>, <code>firstName</code>, and <code>lastName</code>, each of them being 8 bytes long themselves as they are all pointers.
</p>
<p>Here‚Äôs another way to look at what the <code>deref</code> property is doing. Explore the <code>SBType</code> class (you can look that one up yourself) of the <code>SBValue</code>.
</p><pre class="code-block">(lldb) script print a.type.name</pre>
<p>You‚Äôll get this:
</p><pre class="code-block">DSObjectiveCObject *</pre>
<p>Now do the same thing through the <em>deref</em> property:
</p><pre class="code-block">(lldb) script print a.deref.type.name</pre>
<p>You‚Äôll now get the normal class:
</p><pre class="code-block">DSObjectiveCObject</pre>
<h3 class="segment-chapter">Viewing raw data through SBValue</h3>

<p>You can even dump the raw data out with the <code><em>data</em></code> property in <code>SBValue</code>! This is represented by a class named <code><em>SBData</em></code>, which is yet another class you can check out on your own.
</p>
<p>Print out the data of the pointer to <code>DSObjectiveCObject</code>:
</p><pre class="code-block">(lldb) script print a.data</pre>
<p>This will print out the physical bytes that make up the object. Again, this is the pointer to <code>DSObjectiveCObject</code>, not the object itself.
</p><pre class="code-block">60 32 03 00 80 60 00 00                          `2...`..</pre>
<p>Remember, each byte can be represented as two digits in hexadecimal.
</p>
<p>Do you remember covering the <em>little-endian</em> formatting in Chapter 11, ‚ÄúAssembly &amp; Memory‚Äù and how the raw data is reversed?
</p>
<p>Compare this with the <code><em>value</em></code> property of <code>SBValue</code>.
</p><pre class="code-block">(lldb) script print a.value
0x0000608000033260</pre><div class="image-60"><img src="graphics/img125.png"  alt="" title="" /></div>
<p>Notice how the values have been flipped. For example, the final two hex digits of my pointer are the first grouping (aka byte) in the raw data. In my case, the raw data contains <code>0x60</code> as the first value, while the pointer contains <code>0x60</code> as the final value.
</p>
<p>Use the <code><em>deref</em></code> property to grab <i>all</i> the bytes that make up this <code>DSObjectiveCObject</code>.
</p><pre class="code-block">(lldb) script print a.deref.data
f0 54 b8 0d 01 00 00 00 00 0e 07 00 80 60 00 00  .T...........`..
68 33 b8 0d 01 00 00 00 88 33 b8 0d 01 00 00 00  h3.......3......</pre>
<p>This is yet another way to visualize what is happening. You were jumping 8 bytes each time when you were spelunking in memory with that cute <code>po *(id*)(0x0000608000033260 + multiple_of_8)</code> command.
</p>
<h3 class="segment-chapter">SBExpressionOptions</h3>

<p>As mentioned when discussing the <code>EvaluateExpression</code> API, there‚Äôs an optional second parameter that will take an instance of type <em>SBExpressionOptions</em>. You can use this command to pass in specific options for the JIT execution.
</p>
<p>In LLDB, clear the screen, start fresh and type the following:
</p><pre class="code-block">(lldb) script options = lldb.SBExpressionOptions()</pre>
<p>You‚Äôll get no output upon success. Next, type:
</p><pre class="code-block">(lldb) script options.SetLanguage(lldb.eLanguageTypeSwift)</pre>
<p><code><em>SBExpressionOptions</em></code> has a method named <code><em>SetLanguage</em></code> (when in doubt, use <code><em>gdocumentation SBExpressionOptions</em></code>), which takes an LLDB module enum of type <em>lldb::LanguageType</em>. The LLDB authors have a convention for sticking an &quot;e&quot; before an enum, the enum name, then the unique value.
</p>
<p>This sets the options to evaluate the code as Swift instead of whatever the default is, based on the language type of <code>SBFrame</code>.
</p>
<p>Now tell the <code>options</code> variable to interpret the JIT code as a of type ID (i.e. <code>po</code>, instead of <code>p</code>):
</p><pre class="code-block">(lldb) script options.SetCoerceResultToId()</pre>
<p><code><em>SetCoerceResultToId</em></code> takes an optional Boolean, which determines if it should be interpreted as an <code>id</code> or not. By default, this is set to <code>True</code>.
</p>
<p>To recap what you did here: you set the options to parse this expression using the Python API instead of the options passed to us through the expression command.
</p>
<p>For example, <code>SBExpressionOptions</code> you‚Äôve declared so far is pretty much equivalent to the following options in the <code>expression</code> command:
</p><pre class="code-block">expression -lswift -O -- your_expression_here</pre>
<p>Next, create an instance of the <code>ASwiftClass</code> method only using the <code>expression</code> command. If this works, you‚Äôll try out the same expression in the <code>EvaluateExpression</code> command. In LLDB type the following:
</p><pre class="code-block">(lldb) e -lswift -O -- ASwiftClass()</pre>
<p>You‚Äôll get an ugly little error for output...
</p><pre class="code-block">error: &lt;<span class="hljs-type">EXPR</span>&gt;:<span class="hljs-number">3</span>:<span class="hljs-number">1</span>: error: use of unresolved identifier '<span class="hljs-type">ASwiftClass'</span>
<span class="hljs-type">ASwiftClass</span>()
^~~~~~~~~~~</pre>
<p>Oh yeah, ‚Äî you need to import the <em>Allocator</em> module to make Swift play nicely in the debugger.
</p>
<p>In LLDB:
</p><pre class="code-block">(lldb) e -lswift -- import Allocator</pre>
<div class="note">
<p><em>Note</em>: This is a problem many LLDB users complain about: LLDB can‚Äôt properly evaluate code that should be able to execute. Adding this import logic will modify LLDB‚Äôs Swift <em>expression prefix</em>, which is basically a set of header files that a referenced right before you JIT code is evaluated.
</p>
<p>LLDB can‚Äôt see the class <code>ASwiftClass</code> in the JIT code when you‚Äôre stopped in the non-Swift debugging context. This means you need to append the headers to the expression prefix that belongs to the Allocator module.
</p>
<p>There‚Äôs a great explanation from one of the LLDB authors about this very problem here: <a href="http://stackoverflow.com/questions/19339493/why-cant-lldb-evaluate-this-expression">http://stackoverflow.com/questions/19339493/why-cant-lldb-evaluate-this-expression</a>.
</p></div>

<p>Execute the previous command again. Up arrow twice then Enter:
</p><pre class="code-block">(lldb) e -lswift -O -- ASwiftClass()</pre>
<p>You‚Äôll get a reference to an instance of the <code>ASwiftClass()</code>.
</p>
<p>Now that you know this works, use the <code><em>EvaluateExpression</em></code> method with the <code>options</code> parameter as the second parameter this time and assign the output to the variable <code><em>b</em></code>, like so:
</p><pre class="code-block">(lldb) script b = lldb.target.EvaluateExpression(&apos;ASwiftClass()&apos;, options)</pre>
<p>If everything went well, you‚Äôll get a reference to a <code>SBValue</code> in the <code>b</code> Python variable.
</p>
<div class="note">
<p><em>Note</em>: It‚Äôs worth pointing out some properties of <code>SBValue</code> will not play nicely with Swift. For example, dereferencing a Swift object with <code>SBValue</code>‚Äôs <code>deref</code> or <code>address_of</code> property will not work properly. You can coerce this pointer to an Objective-C reference by casting the pointer as a <code>SwiftObject</code>, and everything will then work fine. Like I said, they make you work for it when you‚Äôre trying to go after pointers in Swift!
</p></div>

<h3 class="segment-chapter">Referencing variables by name with SBValue</h3>

<p>Referencing child <code>SBValues</code> via <code><em>GetChildAtIndex</em></code> from <code>SBValue</code> is a rather ho-hum way to navigate to an object in memory. What if the author of this class added a property before <code>eyeColor</code> that totally screwed up your offset logic when traversing this <code>SBValue</code>?
</p>
<p>Fortunately, <code>SBValue</code> has yet <i>another</i> method that lets you reference instance variables by name instead of by offset: <code><em>GetValueForExpressionPath</em></code>.
</p>
<p>Jump back to LLDB and type the following:
</p><pre class="code-block">(lldb) script print b.GetValueForExpressionPath(&apos;.firstName&apos;)</pre>
<p>You can keep drilling down into the child‚Äôs own struct if you wish:
</p>
<p>How did I obtain the name of child <code>SBValue</code>s? If you had no clue of the name for the child <code>SBValue</code>, all you have to do is get to the child using the <code><em>GetIndexOfChild</em></code> API, then use the <code><em>name</em></code> property on that <code>SBValue</code> child.
</p>
<p>For example, if I didn‚Äôt know the name of the <code>UIColor</code> property found in the <em>b</em> <code>SBValue</code>, I could do the following:
</p><div class="image-90"><img src="graphics/img126.png"  alt="" title="" /></div>
<h2 class="segment-chapter">lldb.value</h2>

<p>One final cool thing you can do is create a Python reference that contains the <code>SBValue</code>‚Äôs properties as the Python object‚Äôs properties (wait... what?). Think of this as an object through which you can reference variables using Python properties instead of Strings.
</p>
<p>Back in the console, instantiate a new <code><em>value</em></code> object from your <code><em>b</em></code> <code>SBValue</code>:
</p><pre class="code-block">(lldb) script c = lldb.value(b)</pre>
<p>This will create the special LLDB Python object of type <code>value</code>. Now you can reference its instance variables just like you would a normal object!
</p>
<p>Type the following into LLDB:
</p><pre class="code-block">(lldb) script print c.firstName</pre>
<p>You can also cast the child object back into an <code>SBValue</code> so you can query it or apply it to a <code>for</code> loop, like so:
</p><pre class="code-block">(lldb) script print c.firstName.sbvalue.signed</pre>
<p>Again, if you don‚Äôt know the name of a child <code>SBValue</code>, use the <code>GetChildAtIndex</code> API to get the child and get its name from the <code>name</code> property.
</p>
<div class="note">
<p><em>Note</em>: Although the <code>lldb.value</code> class is awesome, this comes at a cost. It‚Äôs rather expensive to create and access properties through this type of class. If you are parsing a huge <code>NSArray</code> (or <code>Array&lt;Any&gt;</code>, for you Swifties), using this class will definitely slow you down. Play around with it and find the sweet spot between speed and convenience.
</p></div>

<h2 class="segment-chapter">Where to go from here?</h2>

<p>Holy cow... how dense was that chapter!? Fortunately you have come full circle. You can use the options provided by your custom command to dynamically generate your JIT script code. From the return value of your JIT code, you can write scripts that have custom logic based upon the return <code>SBValue</code> that is parsed through the <code>EvaluateExpression</code> APIs.
</p>
<p>This can unlock some amazing scripts for you. In any process to which you can attach LLDB, you can run your own custom code and handle your own custom return values within your Python script. There‚Äôs no need to deal with signing issues or loading of frameworks or anything like that.
</p>
<p>The remaining chapters in this section will focus on the composition of some creative scripts and how they can make your debugging (or reverse engineering) life much simpler. Theory time is over. It‚Äôs time for some fun!
</p></body></html>
