<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" type="text/css" href="dbg.css"/>
  <title>Chapter 23: SB Examples, Resymbolicating a Stripped ObjC Binary</title>
</head>
<body class="segment-chapter">

<!-- metadata: nil  -->


<h1 class="segment-chapter">Chapter 23: SB Examples, Resymbolicating a Stripped ObjC Binary</h1>

<p>This will be a novel example of what you can do with some knowledge of the Objective-C runtime mixed in with knowledge of the lldb Python module.
</p>
<p>When LLDB comes up against a stripped executable (an executable devoid of DWARF debugging information), LLDB won’t have the symbol information to give you the stack trace.
</p>
<p>Instead, LLDB will generate a <em>synthetic</em> name for a method it recognizes as a method, but doesn’t know what to call it.
</p>
<p>Here’s an example of a synthetic method created by LLDB on an always fun to explore process...
</p><pre class="code-block">___lldb_unnamed_symbol906$$<span class="hljs-type">SpringBoard</span></pre>
<p>One strategy to reverse engineer the name of this method is to create a breakpoint on it and explore the registers right at the start of the method.
</p>
<p>Using your assembly knowledge of the Objective-C runtime, you know the <code><em>RSI</em></code> register (x64) or the <code><em>X1</em></code> register (ARM64) will contain the Objective-C Selector that holds the name of method. In addition, you also have the <code><em>RDI</em></code> (x64) or <code><em>X0</em></code> (ARM64) register which holds the reference to the instance (or class).
</p>
<p>However, as soon as you leave the function prologue, you have no guarantee that either of these registers will contain the values of interest, as they will likely be overwritten. What if a stripped method of interest calls another function? The registers you care about are now lost, as they’re set for the parameters for this new function. You need a way to resymbolicate a stack trace without having to rely upon these registers.
</p>
<p>In this chapter, you’ll build an LLDB script that will resymbolicate stripped Objective-C functions in a stack trace.
</p><div class="image-100"><img src="graphics/img131.png"  alt="" title="" /></div>
<p>When you called <code><em>bt</em></code> for this process, LLDB didn’t have the function names for the highlighted methods.
</p>
<p>You will build a new command named <code><em>sbt</em></code> that will look for stripped functions and try to resymbolicate them using the Objective-C runtime. By the end of the chapter, your <code>sbt</code> command will produce this:
</p><div class="image-100"><img src="graphics/img132.png"  alt="" title="" /></div>
<p>Those once stripped-out Objective-C function calls are now resymbolicated.
</p>
<p>As with any of these scripts, you can run this new <code>sbt</code> script on any Objective-C executable provided LLDB can attach to it.
</p>
<h2 class="segment-chapter">So how are you doing this, exactly?</h2>

<p>Let’s first discuss how one can go about resymbolicating Objective-C code in a stripped binary with the Objective-C runtime.
</p>
<p>The Objective-C runtime can list all classes from a particular image (an image being the main executable, a dynamic library, an <code>NSBundle</code>, etc.) provided you have the full path to the image. This can be accomplished through the <em>objc</em><em>_</em><em>copyClassNamesForImage</em> API.
</p>
<p>From there, you can get a list of all classes returned by <code>objc_copyClassNamesForImage</code> where you can dump all class and instance methods for a particular class using the <code><em>class_copyMethodList</em></code> API.
</p>
<p>Therefore, you can grab all the method addresses and compare them to the addresses of the stack trace. If the stack trace’s function can’t generate a default function name (such as if the <code>SBSymbol</code> is synthetically generated by LLDB), then you can assume LLDB has no debug info for this address.
</p>
<p>Using the lldb Python module, you can get the starting address for a particular function — even when a function’s execution is partially complete. This is accomplished using <code>SBValue</code>’s reference to an <code>SBAddress</code>. From there, you can compare the addresses of all the Objective-C methods you’ve obtained to the starting address of the synthetic <code>SBSymbol</code>. If two addresses match, then you can swap out the stripped (synthetic) method name and replace it with the function name that was obtained with the Objective-C runtime.
</p>
<p>Don’t worry: You’ll explore this systematically using LLDB’s <em>script</em> command before you go building this Python script.
</p>
<h2 class="segment-chapter">50 Shades of Ray</h2>

<p>Included in the starter directory is an application called <em>50 Shades of Ray</em>. A well-chosen name (in my humble opinion) for a project that showcases the many faces of Ray Wenderlich.
</p>
<p>There’s gentle Ray, there’s superhero Ray, there’s confused Ray, there&apos;s even goat BFF Ray!
</p><div class="image-40"><img src="graphics/img133.png"  alt="" title="" /></div>
<p>When tapping the <code>UIButton</code> at the bottom, a randomly generated picture of Ray pops up in a <code>UIView</code> of random size.
</p>
<p>Wow, that will make <i>billions</i> on the App Store!
</p>
<p>Open the <em>50 Shades of Ray</em> project and build and run the app. In the Xcode project, there are two schemes. Make sure you select the <em>50 Shades of Ray</em> scheme and not the <em>Stripped</em> scheme. You’ll use that scheme later.
</p>
<p>Once you’ve gotten your enjoyment out of generating random pictures of Ray, click on the <em>ObjC</em> <code>UIBarButtonItem</code> in the upper right hand corner.
</p><div class="image-90"><img src="graphics/img134.png"  alt="" title="" /></div>
<p>This <code>UIBarButtonItem</code> is tied to an <code>IBAction</code> that will print out all the methods implemented by the main executable and displays them to stderr in your console. In fact, you can see the name of the method that triggered the console output within the console output!
</p>
<p>Scan the console for the method <em>-</em><em>[</em><em>ViewController dumpObjCMethodsTapped:</em><em>]</em>. It’s this method which dumped all the Objective-C methods in the main executable.
</p>
<p>Preceding the function is a number (in my case, <code>4449531728</code>), which holds the starting address for this Objective-C method.
</p>
<p>Don’t believe me? Pause execution and type the following into LLDB:
</p><pre class="code-block">(lldb) image lookup -a 4449531728</pre>
<p>You address will be different. This is hunting down the location of the address <em>4483016672</em> in memory and seeing where it relates in reference to your project.
</p><pre class="code-block">Address: 50 Shades of Ray[0x00000001000017e0] (50 Shades of Ray.__TEXT.__text + 624)
Summary: 50 Shades of Ray`-[ViewController dumpObjCMethodsTapped:] at ViewController.m:36</pre>
<p>Groovy. This is telling us the location in memory <code>4449531728</code> is what was loaded from <code><em>-[ViewController dumpObjCMethodsTapped:]</em></code>. Let’s look at the code in this method.
</p>
<p>Head on in to <em>ViewController.m</em> and hunt for the <em>dumpObjCMethodsTapped:</em>
</p>
<p>The exact details don’t need to be covered too closely, but it’s worth pointing out the following:
</p>
<ul>
<li>
<p>All the Objective-C classes implemented in the main executable are enumerated through <code><em>objc_copyClassNamesForImage</em></code>.
</p></li>

<li>
<p>For each class, there’s logic to grab all the class and instance methods.
</p></li>

<li>
<p>In order to grab the class methods for a particular Objective-C Class, you must get the <em>meta class</em>. No, that term was not made up by some hipster developer in tight jeans, plaid shirt &amp; beard. The meta class is the class responsible for the static methods of a particular class. For example, all methods that begin with <em>+</em> are implemented by the meta Class and not the Class.
</p></li>

<li>
<p>All the methods are aggregated into a <code>NSMutableDictionary</code>, where the key for each of these methods is the location in memory where the function resides.
</p></li>
</ul>

<h3 class="segment-chapter">Using script to guide your way</h3>

<p>Time to use the <code><em>script</em></code> LLDB command to explore the lldb module APIs and build a quick POC to see how you’re going to tackle finding the starting address of a function in memory.
</p>
<p>In the LLDB console, set a breakpoint on <em>NSLog</em>:
</p><pre class="code-block">(lldb) b NSLog</pre>
<p>You’ll get multiple <code>SBBreakpointLocation</code> hits. That’s fine. Now continue running the application.
</p>
<p>Tap on the <em>ObjC</em> <code>UIBarButtonItem</code> in the upper right corner of the Simulator.
</p>
<p>Execution will stop right before content is spat out to <code>stderr</code>.
</p>
<p>Using the global variable <code><em>lldb.frame</em></code>, dig into what APIs are available to you to grab the starting address of the <code>NSLog</code> function.
</p>
<p>Start with the global variable and build from there.
</p><pre class="code-block">(lldb) script print lldb.frame</pre>
<p>You’ll get the <code>__str__()</code> representation of the <code>SBFrame</code>. Nothing new.
</p><pre class="code-block">frame #0: 0x000000010b472390 Foundation`NSLog</pre>
<p>If you decided to use <code><em>gdocumentation</em></code> to search documentation for <code>SBFrame</code> (from Chapter 19, “Script Bridging Classes and Hierarchy”, you’ll see <code>SBFrame</code> has a few potential candidates for getting the start address of a function. <code><em>pc</em></code> looks interesting to grab the <code>RIP</code> regster (x64) or the <code>PC</code> (ARM64), but that will only work at the start of a function. You need to grab the starting address from any offset inside the <code>SBFrame</code>.
</p>
<p>Unfortunately, there are no APIs you can use in the <code>SBFrame</code> to get the starting address from any instruction offset within the function. You’ll need to turn your attention to other classes referenced by the <code>SBFrame</code> to get what you need.
</p>
<p>Grab the <code><em>SBSymbol</em></code> reference for the <code>SBFrame</code>:
</p><pre class="code-block">(lldb) script print lldb.frame.symbol</pre>
<p>The <code>SBSymbol</code> is responsible for the implementation offset address of <code>NSLog</code>. That is, the <code>SBSymbol</code> will tell you where this function is implemented in a module; it doesn’t hold the actual address of where the <code>NSLog</code> was loaded into memory.
</p>
<p>However, you can use the <code>SBAddress</code> property along with the <code><em>GetLoadAddress</em></code> API of <code>SBAddress</code> to find where the start location of <code>NSLog</code> is in your current process.
</p><pre class="code-block">(lldb) script print lldb.frame.symbol.addr.GetLoadAddress(lldb.target)</pre>
<p>You’ll get a number in decimal. I got <em>4484178832</em>. Convert it to hex using LLDB and compare the output to the start address of <code>NSLog</code>:
</p><pre class="code-block">(lldb) p/x 4484178832</pre>
<p>I got <em>0x000000010b472390</em> as my hexadecimal representation.
</p>
<p>Compare your output with the starting address of <code>NSLog</code> to see if they match.
</p><div class="image-100"><img src="graphics/img135.png"  alt="" title="" /></div>
<p>Woot! A match! That’s your path to resymbolication redemption.
</p>
<h3 class="segment-chapter">lldb.value with NSDictionary</h3>

<p>Since you’re already here, you can explore one more thing. How are you going to parse this <code>NSDictionary</code> with all these addresses?
</p>
<p>You&apos;ll copy the code, <i>almost</i> verbatim, that generates all the methods and apply it to an <code><em>EvaluateExpression</em></code> API to get an <code>SBValue</code>.
</p>
<p>You should still be paused at the beginning of <code>NSLog</code>. Jump to the calling frame, <em>-</em><em>[</em><em>ViewController dumpObjCMethodsTapped:</em><em>]</em>.
</p><pre class="code-block">(lldb) f 1</pre>
<p>This will get to the previous frame, <code>dumpObjCMethodsTapped:</code>. You now have access to all variables within this method, including the <code><em>retdict</em></code> that’s responsible for dumping out all the methods implemented within the main executable.
</p>
<p>Grab the <code>SBValue</code> interpretation of the <code><em>retdict</em></code> reference.
</p><pre class="code-block">(lldb) script print lldb.frame.FindVariable(&apos;retdict&apos;)</pre>
<p>This will print the <code>SBValue</code> for <code>retdict</code>:
</p><pre class="code-block">(__NSDictionaryM *) retdict = 0x000060800024ce10 10 key/value pairs</pre>
<p>Since this an <code>NSDictionary</code>, you actually want to dereference this value so you can enumerate it.
</p><pre class="code-block">(lldb) script print lldb.frame.FindVariable(&apos;retdict&apos;).deref</pre>
<p>You’ll get some more relevant output (which is truncated):
</p><pre class="code-block">(__NSDictionaryM) *retdict = {
  [0] = { 
    key = 0x000060800002bb80 @&quot;4411948768&quot;
    value = 0x000060800024c660 @&quot;-[AppDelegate window]&quot;
  }
  [1] = {
    key = 0x000060800002c1e0 @&quot;4411948592&quot;
    value = 0x000060800024dd10 @&quot;-[ViewController toolBar]&quot;
  }
  [2] = {
    key = 0x000060800002bc00 @&quot;4411948800&quot;
    value = 0x000060800024c7e0 @&quot;-[AppDelegate setWindow:]&quot;
  }
  [3] = {
    key = 0x000060800002bba0 @&quot;4411948864&quot;
    value = 0x000060800004afe0 @&quot;-[AppDelegate .cxx_destruct]&quot;
  }</pre>
<p>It’s this you want to start with, since this prints out all the <code>value</code>s for the <code>key</code>s.
</p>
<p>Make a <code><em>lldb.value</em></code> out of this <code>SBValue</code> and assign it to a variable <code><em>a</em></code>.
</p><pre class="code-block">(lldb) script a = lldb.value(lldb.frame.FindVariable(&apos;retdict&apos;).deref)</pre>
<p>This is one of those times where I would prefer to work with an <code>lldb.value</code> over an <code>SBValue</code>. From here, you can easily explore the values within this <code>NSDictionary</code>.
</p>
<p>Print the first value within this <code>lldb.value</code> <code>NSDictionary</code>.
</p><pre class="code-block">(lldb) script print a[0]</pre>
<p>From there, you can have either the <code>key</code> or <code>value</code> that you can print out.
</p>
<p>Print out the <code>key</code> first:
</p><pre class="code-block">(lldb) script print a[0].key</pre>
<p>You’ll get something similar to the following:
</p><pre class="code-block">(__NSCFString *) key = 0x000060800002bb80 @&quot;4411948768&quot;</pre>
<p>Print the <code>value</code>:
</p><pre class="code-block">(lldb) script print a[0].value</pre>
<p>This will print something similar to the following:
</p><pre class="code-block">(__NSCFString *) value = 0x000060800024c660 @&quot;-[AppDelegate window]&quot;</pre><div class="image-90"><img src="graphics/img136.png"  alt="" title="" /></div>
<p>If you only want the return value without the referencing address, you’ll need to cast this <code>lldb.value</code> back into a <code>SBValue</code> then grab the <code>description</code>.
</p><pre class="code-block">(lldb) script print a[0].value.sbvalue.description</pre>
<p>This will get you the desired <code><em>-[AppDelegate window]</em></code> for output. Note you may have a different method.
</p>
<p>If you wanted to dump all <code>key</code>s in this <code>lldb.value</code> <code>a</code> instance, you can use Python List comprehensions to dump all the keys out.
</p><pre class="code-block">(lldb) script print &apos;\n&apos;.join([x.key.sbvalue.description for x in a])</pre>
<p>You’ll get output similar to the following:
</p><pre class="code-block">4411948768
4411948592
4411948800
4411948864
4411948656
4411948720
4411949072
4411946944
4411946352
4411946976</pre>
<p>Same approach for <code>value</code>s:
</p><pre class="code-block">(lldb) script print &apos;\n&apos;.join([x.value.sbvalue.description for x in a])</pre>
<p>You now know how to parse this <code>NSDictionary</code> if, hypothetically, it were to be placed in some JIT code...
</p>
<p>The plan is to copy the code from the <code>dumpObjCMethodsTapped:</code> into the Python script, and have it execute as JIT code. From there, you’ll use the same procedure to parse it out from the <code>NSDictionary</code>.
</p>
<p>Sounds good? Get your gameplan ready and head on in to the next section!
</p>
<h2 class="segment-chapter">The &quot;stripped&quot; 50 Shades of Ray</h2>

<p>Yeah, that title got your attention, didn’t it?
</p>
<p>Within the Xcode schemes of the 50 Shades of Ray executable, there is a scheme named <em>Stripped 50 Shades of Ray</em>.
</p>
<p>Stop the execution of the current process (<em>⌘ + .</em>) and select the <em>Stripped 50 Shades of Ray</em> Xcode scheme.
</p><div class="image-60"><img src="graphics/img137.png"  alt="" title="" /></div>
<p>This scheme will build a debug executable, but remove the debugging information that you have become accustomed to in your day-to-day development cycles.
</p>
<p>Build and run the executable. Included within this project is a <em>shared symbolic breakpoint</em>. Enable this breakpoint.
</p>
<p>There’s no need to modify this symbolic breakpoint, but it’s worth noting what this breakpoint will do.
</p><div class="image-80"><img src="graphics/img138.png"  alt="" title="" /></div>
<p>This breakpoint will stop on <code><em>-[UIView initWithFrame:]</em></code> and has a condition to only stop if the <code>UIView</code> is of type <code><em>RayView</em></code>, a subclass of <code>UIView</code>. This <code>RayView</code> is responsible for displaying the lovely images of Ray Wenderlich within the application.
</p>
<p>Tap the <em>Generate a Ray</em><em>!</em> button. Execution will stop on <code><em>-[UIView initWithFrame:]</em></code> method.
</p>
<p>Take a look at the stack trace.
</p><div class="image-50"><img src="graphics/img139.png"  alt="" title="" /></div>
<p>There’s something interesting about stack frame 1 &amp; 3: There’s no debug information in there. LLDB has defaulted to generating a synthetic function name for those methods.
</p>
<p>Confirm this in LLDB.
</p>
<p>In LLDB, make sure you are in the starting frame (<code>initWithFrame:</code>):
</p><pre class="code-block">(lldb) f 0</pre>
<p>Use <em>script</em> to see if it’s synthetic or not:
</p><pre class="code-block">(lldb) script lldb.frame.symbol.synthetic</pre>
<p>You’ll get <code>False</code>. Makes sense, because you know this is <code>initWithFrame:</code>. Jump to one of the synthetic frames:
</p><pre class="code-block">(lldb) f 1</pre>
<p>Execute the previous <code>script</code> logic:
</p><pre class="code-block">(lldb) script lldb.frame.symbol.synthetic</pre>
<p>You’ll get <code>True</code> this time.
</p>
<p>This is enough research to get you going with the Python script.
</p>
<h2 class="segment-chapter">Building sbt.py</h2>

<p>Included within the <em>starter</em> folder is a Python script named <em>sbt.py</em>.
</p>
<p>Stick this script into your <em>~/lldb</em> directory. Provided you’ve installed the <em>lldbinit.py</em> script, this will load all the Python files into the LLDB directory.
</p>
<p>If you didn’t follow along in Chapter 22, “SB Examples, Improved Lookup”, you can manually install the <code>sbt.py</code> by modifying your <em>~/.lldbinit</em> file.
</p>
<p>Once you’ve placed the sbt.py file into the <em>~/lldb directory</em>, reload your commands in <em>~/.lldbinit</em> using the <em>reload</em><em>_</em><em>script</em> you created in Chapter 19, “Script Bridging Classes and Hierarchy”.
</p>
<p>Check and see if LLDB correctly recognizes the <code>sbt</code> command:
</p><pre class="code-block">(lldb) help sbt</pre>
<p>You’ll get some help text if LLDB recognizes the command. This will be the starting point for the <code>sbt</code> command.
</p>
<p>Open this file up and jump down to <code><em>generateExecutableMethodsScript</em></code>. There’s something interesting here that’s worth pointing out.
</p>
<p>Do you remember in the previous chapter, how I mentioned <em>lldb.value</em> is slooooooooooooooooow? If you&apos;re exploring a huge executable with lots of methods, the amount of time it takes for Python to go through every value in an <code>NSDictionary</code> takes forever.
</p>
<p>Instead, you don’t need to grab <i>every</i> reference to <i>every</i> single function in your <code>NSDictionary</code>. You only need to grab the locations of the start of each function in the stack trace.
</p><pre class="code-block"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateExecutableMethodsScript</span><span class="hljs-params">(frame_addresses)</span>:</span>
    frame_addr_str = <span class="hljs-string">'NSArray *ar = @['</span>
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> frame_addresses:
        frame_addr_str += <span class="hljs-string">'@"'</span> + str(f) + <span class="hljs-string">'",'</span>

    frame_addr_str = frame_addr_str[:<span class="hljs-number">-1</span>]
    frame_addr_str += <span class="hljs-string">'];'</span>

    <span class="hljs-comment"># #############################</span>
    <span class="hljs-comment"># Truncated content...</span>
    <span class="hljs-comment"># #############################</span>

    command_script += frame_addr_str
    command_script += <span class="hljs-string">r'''
  NSMutableDictionary *stackDict = [NSMutableDictionary dictionary];
  [retdict keysOfEntriesPassingTest:^BOOL(id key, id obj, BOOL *stop) {
    if ([ar containsObject:key]) {
      [stackDict setObject:obj forKey:key];
      return YES;
    }
    return NO;
  }];
  stackDict;
  '''</span>
    <span class="hljs-keyword">return</span> command_script</pre>
<p>This is a pretty sweet optimization, because instead of evaluating potentially thousands (if not tens of thousands) of Objective-C methods, you’ll only need to evaluate less than 20 keys or so in an <code>NSDictionary</code>, or whatever amount of synthetic functions are in the stack frame.
</p>
<p>With the symbolic breakpoint still active and program stopped, give the script a run.
</p>
<p>Just a normal stack frame will be printed out that doesn’t have logic to resymbolicate the symbols.
</p>
<p>It’s time to make a few modifications to fix that.
</p>
<h2 class="segment-chapter">Implementing the code</h2>

<p>The JIT code is already set up. All you need to do is just call it, then compare the return <code>NSDictionary</code> against any synthetic <code>SBValue</code>s.
</p>
<p>Inside <code><em>processStackTraceStringFromAddresses</em></code>, search for the following comments:
</p><pre class="code-block">    <span class="hljs-comment"># New content start 1</span>
    <span class="hljs-comment"># New content end 1</span></pre>
<p>Stick your new code here to call the JIT code to generate a list of potential methods in a <code>NSDictionary</code>:
</p><pre class="code-block">    <span class="hljs-comment"># New content start 1</span>
    methods = target.EvaluateExpression(script, generateOptions())
    methodsVal = lldb.value(methods.deref)
    <span class="hljs-comment"># New content end 1</span></pre>
<p>You’ve called the code that returns the <code>NSDictionary</code> representation and assigned it to the <code>SBValue</code> instance variable <code><em>methods</em></code>.
</p>
<p>You can cast the <code><em>SBValue</em></code> into a <code><em>lldb.value</em></code> (technically it’s just a <code><em>value</em></code>, but you might get confused if I don’t have the module in there) and assign it to the variable <code><em>methodsVal</em></code>.
</p>
<p>Now for the final part of Python code. All you need to do is determine if a <code>SBFrame</code>’s <code>SBSymbol</code> is <code>synthetic</code> or not and perform the appropriate logic.
</p>
<p>Search the following commented out code further down in <code>processStackTraceStringFromAddresses</code>:
</p><pre class="code-block">    <span class="hljs-comment"># New content start 2</span>
    name = symbol.name
    <span class="hljs-comment"># New content end 2</span></pre>
<p>Change this to look like the following:
</p><pre class="code-block">  <span class="hljs-comment"># New content start 2</span>
  <span class="hljs-keyword">if</span> symbol.synthetic: <span class="hljs-comment"># 1</span>
      children = methodsVal.sbvalue.GetNumChildren() <span class="hljs-comment"># 2</span>
      name = symbol.name + <span class="hljs-string">r' ... unresolved womp womp'</span> <span class="hljs-comment"># 3</span>

      loadAddr = symbol.addr.GetLoadAddress(target) <span class="hljs-comment"># 4</span>

      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(children):
          key = long(methodsVal[i].key.sbvalue.description) <span class="hljs-comment"># 5</span>
          <span class="hljs-keyword">if</span> key == loadAddr:
              name = methodsVal[i].value.sbvalue.description <span class="hljs-comment"># 6</span>
              <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">else</span>:
      name = symbol.name <span class="hljs-comment"># 7</span>

  <span class="hljs-comment"># New content end 2</span>

  offset_str = <span class="hljs-string">''</span></pre>
<p>Breaking this down, you have the following:
</p>
<ol>
<li>
<p>You&apos;re enumerating the frames, which occur outside the scope of this code block. For each symbol, a check is performed to see if the symbol is <code>synthetic</code> or not. If it is, the memory address will be compared to the <code>NSDictionary</code> of addresses that were gathered.
</p></li>

<li>
<p>This will grab the number of children in the <code>lldb.value</code> that will be enumerated to see if there’s a match from the Objective-C list of classes.
</p></li>

<li>
<p>Either way, a valid reference to the <code>name</code> variable needs to be produced for the display of the stack trace. You&apos;re opting to say you know this is a synthetic function, but fail to resolve it if your upcoming logic fails to produce a result.
</p></li>

<li>
<p>This gets the address in memory to the synthetic function in question.
</p></li>

<li>
<p>The <code>key</code> value given by the <code>lldb.value</code> is internally made up from a <code>NSNumber</code>, so you need to grab the <code><em>description</em></code> of this method and cast it into a number. Confusingly, it’s assigned to a Python variable named <code>key</code> as well.
</p></li>

<li>
<p>If the <code>key</code> variable is equal to the <code>loadAddr</code>, then you have a match. Assign the <code>name</code> variable to the <code>description</code> of the variable in the <code>NSDictionary</code>.
</p></li>
</ol>

<p>That should be it. Save your work and reload your LLDB contents using <code>reload_script</code> and give it a go.
</p>
<p>Provided you are still in the <code>Stripped 50 Shades of Ray</code> scheme and are paused in the symbolic breakpoint that stops only in <code>UIView</code>’s <code>initWithFrame:</code> (with the special condition), run the <code><em>sbt</em></code> command in the debugger to see if the originally unavailable frames 1 &amp; 3 can be read.
</p><pre class="code-block">frame #0: 0x1053fe694 UIKit`-[UIView initWithFrame:] 
frame #1: 0x103cf53ac ShadesOfRay`-[RayView initWithFrame:] + 924
frame #2: 0x1053fdda2 UIKit`-[UIView init] + 62
frame #3: 0x103cf45bf ShadesOfRay`-[ViewController generateRayViewTapped:] + 79</pre>
<p>Beautiful.
</p>
<h2 class="segment-chapter">Where to go from here?</h2>

<p>Congratulations! You’ve used the Objective-C runtime to successful resymbolicate a stripped binary! It’s crazy what you can do with the proper application of Objective-C.
</p>
<p>There are still a few holes in this script. This script doesn’t play nice with Objective-C blocks. However, a careful study of how blocks are implemented as well as exploring the lldb Python module <i>might</i> reveal a way to indicate Objective-C block functions that have been stripped away.
</p>
<p>In addition, this script will not work with an iOS executable in release mode. LLDB will not find the functions for a synthetic <code>SBSymbol</code> to reference the start address. This means that you would have to manually search upwards in the ARM64 assembly until you stumbled across an assembly instruction that looked like the start of a function (can you guess which instruction(s) to look for?).
</p>
<p>If those script extensions don’t interest you, try your luck with figuring out how to resymbolicate a Swift executable. The challenge definitely goes up by an order of magnitude, but it’s still within the realm of possibility to do with LLDB.
</p>
<p>Have fun!
</p></body></html>
